								*JENKINS*
						Secure Jenkins Reverse Proxy Architecture


[User Browser]
    |
 HTTPS Request (port 8443)--https://jenkins.isrd.cair.drdo:8443
    |
[NGINX Reverse Proxy Container]
    ‚îú‚îÄ Accepts HTTPS on port 8443
    ‚îú‚îÄ Terminates SSL using TLS certificate--Holds: TLS certificates (/etc/nginx/certs/)
    ‚îú‚îÄ Forwards HTTP request to Jenkins at http://jenkins:8080
    |
 HTTP Request (port 8080)
    |
[Jenkins Container]
    ‚îú‚îÄ Receives the internal HTTP request on port 8080
    ‚îú‚îÄ Processes the request (e.g., load UI, login page, trigger build)
    ‚îî‚îÄ Generates HTTP response (HTML/CSS/JS, JSON API, etc.)
        |
 HTTP Response (port 8080)
        |
[NGINX Reverse Proxy]
    ‚îú‚îÄ Receives the plain HTTP response from Jenkins
    ‚îú‚îÄ Wraps it back into an HTTPS response
    ‚îî‚îÄ Sends it to the user's browser
        |
 HTTPS Response (port 8443)
        |
[User Browser Displays Jenkins UI]


or
[User Browser]
    |
 HTTPS (port 8443)
    |
[NGINX Reverse Proxy]  --TLS termination, holds SSL certs
    |
 HTTP (port 8080)
    |
[Jenkins container]



üéØ Recap 
You (HTTPS) ‚Üí NGINX (SSL Termination) ‚Üí Jenkins (HTTP) ‚Üí NGINX (Re-encrypt) ‚Üí You (HTTPS).



#üåê When You Open https://jenkins.isrd.cair.drdo:8443 in a Browser
#üîÑ Full Workflow:
1. You (Browser)

Type: https://jenkins.isrd.cair.drdo:8443

Your browser initiates a secure HTTPS connection to NGINX (port 8443).



2. NGINX (Reverse Proxy)

Accepts HTTPS (port 8443).

Decrypts SSL/TLS (using certificates stored in /etc/nginx/certs/).
#Decrypts SSL/TLS using the certificate and private key stored in /etc/nginx/certs/, allowing NGINX to securely accept HTTPS traffic and convert it to plain HTTP for internal use.

Forwards the request internally as plain HTTP to Jenkins at http://jenkins:8080 (inside Docker network).


3. Jenkins (Application)

Receives HTTP request (port 8080).

Processes request (e.g., shows login page, runs a build).

Sends back HTTP response (HTML, JSON, etc.) to NGINX.
#Jenkins receives the HTTP request on port 8080, processes it (like showing the UI or running a build), and sends back an HTTP response (such as HTML, JSON, etc.) to NGINX.


4. NGINX (Reverse Proxy - Again)

Takes Jenkins‚Äô HTTP response.

Encrypts it back into HTTPS.

Sends it securely to your browser.
#NGINX receives Jenkins' HTTP response, encrypts it using SSL/TLS, and sends it as a secure HTTPS response to the browser.


5. You (Browser - Final Step)

Receives encrypted HTTPS response.

Displays Jenkins UI securely (üîí lock icon in browser).
#Browser receives the HTTPS response, decrypts it, and securely displays the Jenkins UI (üîí lock icon confirms a trusted connection).



#‚úÖ Ports Summary:
External (You ‚Üí NGINX): 8443 (HTTPS).

Internal (NGINX ‚Üí Jenkins): 8080 (HTTP).


#Recap
--You access https://jenkins.isrd.cair.drdo:8443 in the browser.

--NGINX handles HTTPS, terminates SSL, and forwards HTTP internally to Jenkins.

--Jenkins responds via port 8080, only inside Docker.

--Browser never talks to Jenkins directly ‚Äî only to NGINX.





==================================================================================================================================================

						*Clear explanation of CA and SSL/TLS certificates*


#What is a Certificate Authority (CA)?
A Certificate Authority (CA) is a trusted organization‚Äîlike a passport office‚Äîthat issues SSL/TLS certificates, which are digital IDs verifying a website‚Äôs identity and enabling secure, encrypted HTTPS connections.

--A CA is a trusted organization that issues digital certificates.

--Think of it like a passport office that verifies your identity and gives you a passport.

Examples of CAs: DigiCert, GoDaddy, GlobalSign.


#What is an SSL/TLS Certificate?
--It‚Äôs a digital certificate issued by a CA.

--Acts like a passport for a website proving it is authentic and trusted.

--Enables HTTPS, which means encrypted, secure communication between your browser and the website.

--Companies purchase an SSL/TLS certificate from a trusted CA to enable HTTPS on their websites.



#What is a Root Certificate?
--A Root Certificate is a special SSL/TLS certificate issued by a Root Certificate Authority (Root CA).

--It is the top-most certificate in the chain of trust and is self-signed (signed by the CA itself).

--Root certificates are pre-installed and trusted by browsers and operating systems.

--They verify the authenticity of other certificates issued by the CA (intermediate and server certificates).

--The browser trusts a website‚Äôs certificate only if it can trace it back to a trusted root certificate.



#How it works:
A company (website owner) applies to a CA for an SSL certificate.

The CA verifies the company‚Äôs identity and domain ownership.

The CA issues the SSL certificate to the company.

The website uses this certificate to encrypt data and prove its identity to users.


#Why it matters:

When you visit a website with HTTPS, your browser checks the SSL certificate to ensure it‚Äôs issued by a trusted CA.

If valid, you see a lock icon and your connection is üîísecure.

#example
Root CA = Head Office (top trust)

Intermediate CA = Branch Office (authorized by Head Office)

SSL Certificate = Employee ID card (proves identity)





=================================================================================================================================================				
							     *WEBSERVER*
							        NGINX

#üñ•Ô∏è What is a Server?s
A server is a computer system or software application that provides services, data, or resources to other computers (called clients) over a network. The server "serves" something ‚Äî like web pages, files, or data ‚Äî when requested by a client.

								or
#üí¨ In simple terms:
A server is a computer or software program that provides services, data, or functionality to other computers (clients) over a network.

Server = A computer (or software) that gives something (data/services).

Client = A computer (or software) that asks for something and uses it.

--One computer (server) provides data or services.
--The other computer (client) receives or uses that data.

#‚öôÔ∏è Main Components of a Server:

| Component                  | Description                                                                 |
| -------------------------- | --------------------------------------------------------------------------- |
| **Hardware**               | High-performance computer with powerful CPU, RAM, and storage.              |
| **Operating System**       | Special server OS like **Linux**, **Windows Server**, or **Ubuntu Server**. |
| **Network Interface**      | To connect and communicate with clients over a network (LAN/Internet).      |
| **Server Software**        | Provides specific services like web (Apache, NGINX), database (MySQL), etc. |
| **Storage**                | To store data, websites, databases, or application files.                   |
| **Security Systems**       | Firewalls, antivirus, SSL/TLS for secure data transfer.                     |
| **Power Supply & Cooling** | Keeps the server always running and avoids overheating.                     |


#üì¶ Examples of Server Software:
Web Server: Apache, NGINX

Database Server: MySQL, PostgreSQL

File Server: Samba, FTP

Email Server: Postfix, Microsoft Exchange




#nginx

#What is NGINX?

--NGINX is a software that acts as:

--A web server that delivers website content to users.

--A reverse proxy that forwards user requests to internal servers, hiding them from users.

--An HTTPS security layer that uses SSL/TLS certificates to create secure, encrypted connections.


Nginx (pronounced "engine-x") is a powerful, open-source software platform used for web servers, reverse proxies, email proxies, and load balancing. It's known for its high performance, scalability, and efficiency, particularly in handling high-traffic websites and applications.


#‚úÖ What is a Reverse Proxy?
--A Reverse Proxy is a middle server between the user and the actual backend server (like Tuleap or Jenkins).

--It receives the user's request (like from a browser).

--Then it forwards the request to the real server inside (Tuleap, Jenkins, etc.).

--The backend sends a response back, and the reverse proxy returns that response to the user.

#example
| Role                   | Who it is                       |
| ---------------------- | ------------------------------- |
| You (visitor)          | Browser (Client)                |
| Security Guard at gate | NGINX (Reverse Proxy)           |
|person inside the office | Backend Server (Tuleap/Jenkins) |


#‚öôÔ∏è Why Use Reverse Proxy?
Security ‚Äì SSL/HTTPS is handled at the front.

Hides the real server ‚Äì only NGINX is exposed.

Flexible Routing ‚Äì can direct traffic to different apps.

Load Balancing ‚Äì if needed, can split load to multiple servers.

#NGINX ‡∞Ö‡∞®‡±á‡∞¶‡∞ø ‡∞í‡∞ï ‡∞∏‡∞æ‡∞´‡±ç‡∞ü‡±ç‚Äå‡∞µ‡±á‡∞∞‡±ç ‡∞™‡±ç‡∞∞‡±ã‡∞ó‡±ç‡∞∞‡∞æ‡∞Æ‡±ç, ‡∞á‡∞¶‡∞ø ‡∞™‡±ç‡∞∞‡∞ß‡∞æ‡∞®‡∞Ç‡∞ó‡∞æ ‡∞Æ‡±Ç‡∞°‡±Å ‡∞™‡∞®‡±Å‡∞≤‡±Å ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø:

#‡∞µ‡±Ü‡∞¨‡±ç ‡∞∏‡∞∞‡±ç‡∞µ‡∞∞‡±ç:
‡∞µ‡±Ü‡∞¨‡±ç‚Äå‡∞∏‡±à‡∞ü‡±ç‡∞≤ ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞ï‡∞Ç‡∞ü‡±Ü‡∞Ç‡∞ü‡±ç (‡∞™‡±á‡∞ú‡±Ä‡∞≤‡±Å, ‡∞´‡±à‡∞≥‡±ç‡∞≥‡±Å) ‡∞®‡±Å ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç‡∞≤‡∞ï‡±Å ‡∞Ö‡∞Ç‡∞¶‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø. ‡∞Ö‡∞Ç‡∞ü‡±á, ‡∞Æ‡±Ä‡∞∞‡±Å ‡∞¨‡±ç‡∞∞‡±å‡∞ú‡∞∞‡±ç‚Äå‡∞≤‡±ã ‡∞µ‡±Ü‡∞¨‡±ç‚Äå‡∞∏‡±à‡∞ü‡±ç ‡∞Ö‡∞°‡∞ø‡∞ó‡∞ø‡∞®‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å, NGINX ‡∞Ü ‡∞°‡±á‡∞ü‡∞æ‡∞®‡±Å ‡∞™‡∞Ç‡∞™‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø.

#‡∞∞‡∞ø‡∞µ‡∞∞‡±ç‡∞∏‡±ç ‡∞™‡±ç‡∞∞‡∞æ‡∞ï‡±ç‡∞∏‡±Ä:
‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç‚Äå‡∞≤‡±Å ‡∞Æ‡±Å‡∞Ç‡∞¶‡±Å‡∞ó‡∞æ NGINX ‡∞§‡±ã ‡∞ï‡∞®‡±Ü‡∞ï‡±ç‡∞ü‡±ç ‡∞Ö‡∞µ‡±Å‡∞§‡∞æ‡∞∞‡±Å. NGINX ‡∞µ‡∞æ‡∞∞‡∞ø ‡∞µ‡∞ø‡∞ú‡±ç‡∞û‡∞™‡±ç‡∞§‡∞ø‡∞®‡∞ø (request) ‡∞Ö‡∞Ç‡∞§‡∞∞‡±ç‡∞ó‡∞§‡∞Ç‡∞ó‡∞æ ‡∞â‡∞®‡±ç‡∞® ‡∞µ‡±á‡∞∞‡±á ‡∞∏‡∞∞‡±ç‡∞µ‡∞∞‡±ç‚Äå‡∞ï‡±Å ‡∞™‡∞Ç‡∞™‡±Å‡∞§‡±Å‡∞Ç‡∞¶‡∞ø. ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç‚Äå‡∞ï‡±Å NGINX ‡∞Æ‡∞æ‡∞§‡±ç‡∞∞‡∞Æ‡±á ‡∞ï‡∞®‡∞¨‡∞°‡±Å‡∞§‡±Å‡∞Ç‡∞¶‡∞ø, ‡∞µ‡±Ü‡∞®‡±Å‡∞ï‡∞≤‡±ã ‡∞â‡∞®‡±ç‡∞® ‡∞Ö‡∞∏‡∞≤‡±Å ‡∞∏‡∞∞‡±ç‡∞µ‡∞∞‡±ç ‡∞¶‡∞æ‡∞ö‡∞ø‡∞™‡±Ü‡∞°‡±Å‡∞§‡±Å‡∞Ç‡∞¶‡∞ø.

#HTTPS ‡∞∏‡±Ü‡∞ï‡±ç‡∞Ø‡±Ç‡∞∞‡∞ø‡∞ü‡±Ä:
NGINX SSL/TLS ‡∞∏‡∞∞‡±ç‡∞ü‡∞ø‡∞´‡∞ø‡∞ï‡±á‡∞ü‡±ç‚Äå‡∞≤‡∞®‡±Å ‡∞â‡∞™‡∞Ø‡±ã‡∞ó‡∞ø‡∞Ç‡∞ö‡∞ø ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç‡∞≤‡∞§‡±ã ‡∞∏‡±Å‡∞∞‡∞ï‡±ç‡∞∑‡∞ø‡∞§‡∞Æ‡±à‡∞® (encrypted) ‡∞ï‡∞®‡±Ü‡∞ï‡±ç‡∞∑‡∞®‡±ç‚Äå‡∞®‡±Å ‡∞è‡∞∞‡±ç‡∞™‡∞æ‡∞ü‡±Å ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø. ‡∞¶‡±Ä‡∞®‡∞ø‡∞§‡±ã ‡∞°‡±á‡∞ü‡∞æ ‡∞π‡±ç‡∞Ø‡∞æ‡∞ï‡∞ø‡∞Ç‡∞ó‡±ç ‡∞ï‡∞æ‡∞ï‡±Å‡∞Ç‡∞°‡∞æ ‡∞â‡∞Ç‡∞ü‡±Å‡∞Ç‡∞¶‡∞ø.


#Example: DRDO Office Canteen Analogy
Person cooking inside = Tuleap (backend server)
Gate, cashier outside = NGINX (reverse proxy & web server)

#How it works:
User arrives:
The user types https://tuleap.isrd.cair.drdo in the browser and sends a request.

At the gate (NGINX):
NGINX first checks if the request is secure (using SSL/HTTPS).

NGINX calls Tuleap:
NGINX forwards the user‚Äôs request to Tuleap ‚Äî like saying, ‚ÄúThis user wants the bug list.‚Äù

Tuleap sends the data:
Tuleap prepares the requested data (bug list) and sends it back to NGINX.

NGINX delivers to user:
NGINX sends the data securely (via HTTPS) to the user‚Äôs browser.


NGINX acts like the cashier or gatekeeper who checks and controls all incoming requests. It securely forwards requests to the backend server (Tuleap), which does the actual work. Tuleap sends the results back to NGINX, which then safely delivers it to the user.




#üîß What is Apache Server?
Apache HTTP Server (often just called Apache) is another popular web server software ‚Äî like NGINX ‚Äî that delivers web pages to your browser when you visit a website.


--Apache = An older, experienced chef who prepares one order at a time, carefully and individually.

--NGINX = A fast, modern chef who can handle multiple orders at once using smart scheduling.


üåê
--Apache is often used for complex PHP applications and when .htaccess flexibility is needed.

--NGINX is preferred as a reverse proxy or for high-performance static content delivery.




| Feature          | **NGINX**                                            | **Apache**                              |
| ---------------- | ---------------------------------------------------- | --------------------------------------- |
| üì¶ Type          | Reverse proxy & web server                           | Web server                              |
| ‚öôÔ∏è Working Style | Handles many requests at once (faster)               | One request per process/thread (slower) |
| üîÅ Good for      | Reverse proxy, load balancing, HTTPS front-end       | Backend apps, PHP, `.htaccess` configs  |
| üöÄ Speed         | Fast for high traffic (non-blocking)                 | Can slow down under heavy load          |
| üß† Used for      | Front-end traffic management                         | Serving dynamic web content             |
| üì¶ Inside Docker | Lightweight, ideal for HTTPS proxy to Jenkins/Tuleap | Heavier, often used directly by apps    |



#Tuleap and Jenkins on two different servers, both inside Docker, and you're using HTTPS with NGINX as reverse proxy, 
‚úÖ Best Choice for HTTPS Reverse Proxy
Use: [NGINX] on both servers

| Reason                  | Why NGINX is Better in Your Case                             |
| ----------------------- | ------------------------------------------------------------ |
| ‚ö° Lightweight           | Uses fewer resources than Apache                             |
| üöÄ High performance     | Handles many HTTPS requests faster                           |
| üîí SSL/TLS support      | Easy to configure HTTPS with certs                           |
| üîÅ Reverse proxy use    | Designed for proxying traffic to apps like Jenkins or Tuleap |
| üê≥ Docker-friendly      | Commonly used in container setups                            |
| üîß Simple configuration | Clean config files, easy to reload changes                   |


üîÑ Tuleap HTTPS Access Workflow (With NGINX)
USER (Browser)
    |
 HTTPS Request (port 443)
    ‚Üì
NGINX (Reverse Proxy)
    |
 HTTP Forward (port 8080)
    ‚Üì
Tuleap App (inside Docker)
‚Ü©Ô∏è Response flows back the same way:
Tuleap ‚Üí NGINX ‚Üí Browser

USER (Browser) ‚Üí NGINX (HTTPS) ‚Üí Tuleap (Docker on port 8080)


server {
    # üë§ Step 1: User sends an HTTPS request to tuleap.drdo.in (from their browser)
    listen 443 ssl;
    server_name tuleap.isrd.cair.drdo;

    # üîí Step 2: NGINX uses this certificate and key to decrypt the HTTPS request
    ssl_certificate     /etc/nginx/ssl/drdo.crt;
    ssl_certificate_key /etc/nginx/ssl/drdo.key;

    location / {
        # üì¶ Step 3: NGINX forwards the decrypted request to the Tuleap app running inside Docker on port 8080
        proxy_pass http://localhost:8080;

        # (Optional) You can also add headers for better proxying:
        # proxy_set_header Host $host;
        # proxy_set_header X-Real-IP $remote_addr;
        # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # proxy_set_header X-Forwarded-Proto $scheme;
    }
}


# why only NGINX service exposes port 8443 and Jenkins service does not expose 8443 (or any HTTPS port). Why not?

--Jenkins itself (in the container) listens on HTTP port 8080 internally, not on 8443 or any HTTPS port by default.
--You don‚Äôt expose port 8443 on Jenkins container because Jenkins does NOT run HTTPS server internally.

| Service | Port exposed in Docker Compose     | Purpose                                      |
| ------- | ---------------------------------- | -------------------------------------------- |
| Jenkins | `8080` (internal, no host mapping) | Jenkins listens internally on HTTP only      |
| NGINX   | `8443` mapped to container 8443    | NGINX handles HTTPS termination on this port |



#Why not expose 8443 on Jenkins?
Jenkins itself doesn‚Äôt provide HTTPS in this setup.

NGINX is designed to be the SSL/TLS terminator.

Exposing 8443 on Jenkins container would do nothing unless Jenkins runs HTTPS server on that port (which it doesn‚Äôt).

Keeping Jenkins HTTP internal and NGINX external SSL is a common, clean architecture.

#In short:
Expose port 8443 only on NGINX ‚Äî it handles HTTPS.

Jenkins stays on HTTP port 8080 inside Docker network (no external exposure needed).

NGINX proxies HTTPS requests from port 8443 to Jenkins port 8080.



#Summary
NGINX = Gatekeeper (SSL security + reverse proxy)

Tuleap = Main chef (serves actual data)

Together = Deliver secure, smooth access to users


‚úÖ Default Ports Used by Tuleap
| **Service**         | **Port** | **Protocol** | **Use**                                          |
| ------------------- | -------- | ------------ | ------------------------------------------------ |
| Web UI (HTTP)       | 80       | HTTP         | Default unsecured web access                     |
| Web UI (HTTPS)      | 443      | HTTPS        | Default **secure** web access                    |
| FTP                 | 21       | FTP          | File uploads (rarely used in modern setups)      |
| SSH                 | 22       | SSH          | Developer shell or Git over SSH                  |
| Mail (SMTP)         | 25       | SMTP         | Sending notification emails                      |
| Alternate Web UI    | 8080     | HTTP         | Used in **Docker/Nginx setups** as internal port |
| Alternate Secure UI | 8043     | HTTPS        | Used in **Docker/Nginx** or dev setups           |


#ü§î Why Use Port 8080?
In Docker-based or reverse proxy setups, Tuleap‚Äôs web service runs internally on port 8080, even though users access it via port 443 (HTTPS) externally.

#Example:
External Access (Browser):
You go to https://tuleap.drdo.in (port 443)

Internally in Docker:
NGINX receives that request and proxies it to Tuleap on port 8080




