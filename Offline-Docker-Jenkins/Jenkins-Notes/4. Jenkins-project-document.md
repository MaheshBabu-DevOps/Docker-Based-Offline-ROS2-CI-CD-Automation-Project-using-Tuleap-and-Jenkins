							'''JENKINS-PROCESS'''

					   ***Server-2(docker-Jenkins)--ubuntu host machine***


					 ğŸ“¥ How to Use download-frozen-image-v2.sh from Moby

#Server-2(Jenkins)

âœ… ğŸ”§ Prerequisites to Run Jenkins in Docker on Ubuntu

âœ… 1. Ubuntu Host Requirements
âœ… OS: Ubuntu 20.04 or later (22.04 recommended)
âœ… Internet (initially): Only required for image download/setup unless using offline setup

#âœ… Jenkins Container OS:
--Base OS: Debian GNU/Linux 12 (Bookworm)

--Running inside Docker on Ubuntu 22.04.5 LTS host

--Image: jenkins/jenkins:lts-jdk17

--Shell prompt: root@jenkins:/# â†’ you're inside the container

| Component | OS Base     | Dockerized | HTTPS via NGINX | 
| --------- | ----------- | ---------- | --------------- | 
| Tuleap    | RedHat-like | âœ… Yes      | âœ… Done       |
| Jenkins   | Debian-like | âœ… Yes      | âœ… Using NGINX |



# ğŸ”§ Tools Required to Run Jenkins in Docker (on Ubuntu)
-----------------------------------------------------------------------
| Tool / Package      |                Purpose                        |              
| ------------------- | --------------------------------------------- |
| **docker.io**       | Run Docker containers (Jenkins)               |
| **docker-compose**  | Manage multi-container Docker applications    |
| **git**             | Clone repos (Moby script, Jenkins configs)    |
| **golang-go**       | Required to run `download-frozen-image-v2.sh` |
| **curl**            | Download files, interact with web APIs        |
| **lsb_release -a**  | Identify OS version                           |
-----------------------------------------------------------------------

1ï¸âƒ£ Clone Moby and Install Prereqs
git clone https://github.com/moby/moby.git
cd moby/contrib

#Install Required Packages
sudo apt update
sudo apt install golang-go jq -y


#Make the script executable
chmod +x download-frozen-image-v2.sh

2ï¸âƒ£ Download Docker Images
./download-frozen-image-v2.sh ./jenkins/docker jenkins/jenkins:lts-jdk17  ## Jenkins LTS with JDK17
./download-frozen-image-v2.sh ./nginx/docker nginx:latest		  # Nginx Latest
./download-frozen-image-v2.sh ./ros/docker osrf/ros:humble-desktop	  ## ROS


# Optional additional images
## Monitoring Stack
./download-frozen-image-v2.sh ./prometheus/docker prom/prometheus:latest
./download-frozen-image-v2.sh ./grafana/docker grafana/grafana:latest

## Development Tools
./download-frozen-image-v2.sh ./mailhog/docker mailhog/mailhog:latest
./download-frozen-image-v2.sh ./sonarqube/docker sonarqube:latest


ğŸ“¦ Packaging & Loading Images

3ï¸âƒ£ Create Tar Archive of Jenkins Image
cd ./jenkins/docker
tar -cvf jenkins-docker-image.tar manifest.json repositories *.json


4ï¸âƒ£ Load Image into Docker
docker load -i jenkins-docker-image.tar


5ï¸âƒ£ Verify Image
docker images

# Output Example
docker images | grep -E "jenkins|nginx"
REPOSITORY          TAG         IMAGE ID       CREATED         SIZE
jenkins/jenkins     lts-jdk17    abcd1234abcd   2 days ago    470MB
nginx               latest       xyz9876xyzw    1 week ago    133MB


##Note
------------------------------------------------------------------------------
| File/Folder     | Description                                              |
| --------------- | -------------------------------------------------------- |
| `manifest.json` | Metadata about the Docker image layers and configuration |
| `repositories`  | Information about image names and tags                   |
| `VERSION`       | Docker image format version                              |
| `*.json`        | Metadata files for each image layer                      |
| `*/layer.tar`   | Actual filesystem layer data (contents of the image)     |
------------------------------------------------------------------------------

===================================================================================================================================================










Docker Compose is a tool for defining and managing multi-container Docker applications. It allows users to define an application's services, networks, and volumes in a single YAML file, typically named docker-compose.yml. With a single command, docker compose up, 
#docker-compose.yml

âœ… version: '3.8'
What it means:
Specifies the version of Docker Compose file format being used.
'3.8' is compatible with modern Docker and supports advanced features.

âœ… services:
What it means:
Defines the containers (apps/services) to be run.
Each key under services: (like jenkins) represents one container.

âœ… jenkins:
What it means:
The name of the service (in this case, the Jenkins container).

âœ… image:
What it means:
Tells Docker which image to use for this container.
jenkins/jenkins:lts-jdk17 â†’ Jenkins with Long Term Support (LTS) version using JDK 17.

âœ… hostname:
What it means:
Sets a custom hostname inside the container, useful for internal networking or HTTPS certs.

âœ… container_name:
What it means:
Assigns a custom name to the container instead of a random name.

âœ… user:
What it means:
Runs the container as the specified user.
root is used here so Jenkins can access Docker

--It runs the Jenkins container as the root user inside the container.

--Normally, Jenkins runs as a non-root user (jenkins) for security, but here you're explicitly elevating it to root.

âœ… ports:
What it means:
Maps host ports to container ports.
8080:8080 = Host port 8080 â†’ Jenkins web UI inside the container.
(Port 50000 is commented out: used for external agent connections.)


âœ… volumes: (under jenkins: service)
What it means:
Mounts volumes (for persistent data or host file access):


| **Mount**                                   | **Purpose**                             | **Type**                    |
| ------------------------------------------- | --------------------------------------- | --------------------------- |
| `jenkins_home:/var/jenkins_home`            | Persist Jenkins data                    | ğŸ—‚ï¸ Named volume             |
| `/var/run/docker.sock:/var/run/docker.sock` | Allow Jenkins to talk to Docker daemon  | ğŸ”— Bind mount (host socket) |
| `/usr/bin/docker:/usr/bin/docker`           | Use Docker CLI inside Jenkins container | ğŸ”— Bind mount (host binary) |



âœ… environment:
What it means:
Sets environment variables inside the container.
This section sets environment variables inside the Jenkins container when it starts. These variables help configure how Jenkins behaves and where it stores its data.

#eg:-
| Scenario                    | Recommended approach               |
| --------------------------- | ---------------------------------- |
| Simple test/dev setup       | Jenkins own HTTPS (optional)       |
| Production  usage           | Separate NGINX reverse proxy HTTPS |


#Your case (offline, Docker, NGINX already setup):
#jenkins
--Keep Jenkins running on HTTP internally(8080).
Jenkins Runs on HTTP

In docker-compose.yml, you set:
environment:
  - JENKINS_OPTS=--httpPort=8080 --httpsPort=-1  # Disable HTTPS in Jenkins
  
--NGINX proxies requests to http://jenkins:8080.


#nginx
--Manage SSL certs only in NGINX.
--Use NGINX reverse proxy for HTTPS.

--NGINX handles HTTPS (8443).

NGINX Handles SSL

You configured NGINX with:

jenkins.crt.pem (server certificate)

jenkins.key.pem (private key)

internal-ca.crt.pem (trusted CA chain)

NGINX terminates SSL and forwards traffic to Jenkins over HTTP (no SSL needed inside Jenkins



1. Jenkins running own HTTPS (built-in)
Jenkins serves HTTPS directly using a Java keystore (.jks).

Manages its own SSL certificates and keys.

You must generate/manage Java keystores and configure Jenkins options.

Slightly more complex and less flexible.

Can complicate certificate renewal and management.

Jenkins HTTPS port must be exposed and reachable



2. Jenkins behind a separate NGINX reverse proxy (recommended)
NGINX handles HTTPS termination (SSL certificates and TLS).

Jenkins runs plain HTTP on a local port (e.g., 8080).

NGINX listens on HTTPS port (e.g., 443 or 8443) and forwards requests to Jenkins.

Easier to manage certificates in one place (NGINX).

More flexibleâ€”can add load balancing, caching, or other proxy features.

Cleaner separation of concerns.

Better suited for production environments.




âœ… restart:
What it means:
Controls the containerâ€™s restart behavior.

always â†’ Automatically restart the container if it crashes or when the Docker host reboots.

Ensures the service stays up and recovers from failures without manual intervention.



âœ… networks: (under jenkins)
What it means:
Attaches the Jenkins container to a custom Docker network named jenkins-network.

Enables communication between containers on the same network.

Isolates Jenkins traffic within that network for better security and organization.

#eg:-
networks:
  jenkins-network:
    driver: bridge


#ğŸ”¹ networks: Under Each Service
This section tells which network(s) the container should join.
âœ… Purpose:
It allows containers to talk to each other over private Docker networks (by container name, no IP needed).
services:
  jenkins:
    image: jenkins/jenkins:lts
    networks:
      - jenkins-network

  nginx:
    image: nginx:latest
    networks:
      - jenkins-network

âœ… What happens here?
Both Jenkins and NGINX are connected to jenkins-network.

Inside the NGINX config, you can use http://jenkins:8080 (Jenkins container name!) â€” no need for an IP address.

Docker handles internal DNS and routing.



#jenkins-network
This creates a network named jenkins-network using Docker's default bridge type.

jenkins-network: is just a name you give to a Docker network.

You define it once (under networks:) and reuse it for services that should be connected.

All containers on jenkins-network can talk to each other securely using internal DNS


#driver:
âœ… What is a Docker Network Driver?
A network driver in Docker determines the type of network and how containers connect and communicateâ€”with each other, the host, or the outside world.

#driver: bridge â€“ What It Means
bridge	The default network driver.
Creates a private, internal network for container-to-container comms

| Purpose                         | Explanation                                                                 |
| ------------------------------- | --------------------------------------------------------------------------- |
| Default container communication | Allows containers to talk to each other securely within the same host.      |
| Simplicity                      | No complex setup. Just create a custom bridge and attach containers.        |
| Isolation                       | Containers donâ€™t expose services to host or internet unless you publish it. |
| Custom control                  | You can define named bridge networks to group related containers.           |

#eg:-
services:
  jenkins:
    networks:
      - jenkins-network

  nginx:
    networks:
      - jenkins-network

networks:
  jenkins-network:
    driver: bridge


#Recap
--driver tells Docker how to handle networking.

--bridge is used for communication between containers on the same host.



#types of networks in docker

Use bridge for most single-host Docker setups (default, isolated network).

Use host if you want the container to share the host network directly.

Use none to isolate the containerâ€™s network entirely.

Use overlay for multi-host Docker clusters.

Use ipvlan and macvlan for advanced networking scenarios where containers need direct LAN presence.

#eg:-
s1 (Tuleap)

s2 (Jenkins)

--Use the default Docker bridge networks locally on each server (which isolate containers within that host).

--For communication between s1 and s2, you donâ€™t connect Docker networks across hosts directly (like overlay needs Docker Swarm or Kubernetes).

--Instead, allow communication via the host network IPs â€” the serversâ€™ real LAN IP addresses (e.g., 192.168.3.1 and 192.168.3.2).



#Benefits for your setup:
--Your NGINX reverse proxy and Jenkins container can securely communicate internally.

--No unnecessary external port exposure.

--Easier container name resolution (e.g., NGINX can proxy requests to http://jenkins:8080).

--Cleaner, more secure Docker environment.


#commands
docker network create jenkins-network(manualy)
docker network ls
docker network inspect jenkins-network





âœ… volumes: (bottom section)
A Docker volume is a persistent, isolated storage mechanism for Docker containers. It allows you to store data outside the container's filesystem, ensuring data persistence even when the container is stopped or deleted. This is crucial for applications that need to store databases, logs, configurations, or other data that should survive container lifecycle changes. 

#What it means:
Declares named volumes to be created and managed by Docker.
jenkins_home: stores Jenkins data even if container is removed.

ğŸ”¹ What Is /var/lib/docker/volumes/?
#Location on the Host:
Volume data is physically stored on the host filesystem. By default, Docker stores volumes in /var/lib/docker/volumes/ on Linux systems.
This is Dockerâ€™s default internal storage for named volumes.

#/data 
Inside _data was created by the Jenkins container itself, not by Docker or you.

| Source  | Why `/data` Exists                                                                       |
| ------- | ---------------------------------------------------------------------------------------- |
| Jenkins | Jenkins internally creates `/data` or `/var/jenkins_home/data`                           |
| Tuleap  | Tuleap uses `/data` internally for app storage                                           |
| Docker  | **Only manages volumes**, doesnâ€™t create `/data` folders unless specified in Dockerfiles |


#âœ… volumes:
--This section declares named volumes.

--Docker will create and manage these volumes automatically.

--Volumes are used to persist data outside the containerâ€™s lifecycle.

--Data in volumes stays safe even if the container is removed or recreated.

--jenkins_home is a named volume.

--Used to store Jenkins data like configuration, jobs, plugins, etc.

--Keeps your Jenkins data persistent across container restarts or recreations.

--Volumes are persistent data stores for containers, created and managed by Docker


#Why is this important?
--Containers are ephemeral (temporary by nature).

--Without volumes, all data inside containers would be lost when containers stop or are removed.

--Named volumes provide durable storage managed by Docker.

#Example
volumes:
  jenkins_home:

âœ… Example 2: Custom name
volumes:
  my_custom_jenkins_volume:


#commands

Command	Description
docker volume create	Create a volume
docker volume inspect	Display detailed information on one or more volumes
docker volume ls	List volumes
docker volume prune	Remove unused local volumes
docker volume rm	Remove one or more volumes
docker volume update	Update a volume (cluster volumes only)




âœ… networks: (bottom section)
What it means:
Declares a custom network (named jenkins-network) using the default bridge driver.
Helps containers communicate securely and independently from the host.s




#ğŸ§  What is Docker's bridge network?
bridge is the default network driver used by Docker on Linux hosts.
When you run a container without explicitly specifying a network, Docker connects it to a default bridge network.


docker network ls
	
#ğŸ“Œ Example:
docker run -dit --name mynginx nginx
This nginx container is automatically attached to the default bridge network.

ğŸ”§ How does it work internally?
When Docker creates a bridge network, it also sets up:
A virtual Ethernet bridge (docker0) on the host.
Containers get private IPs (e.g., 172.17.0.2) and connect to docker0.


#ğŸ”§ How does the bridge network work internally?

1. docker0: The Default Bridge Interface on Host
When Docker is installed on Linux, it creates a virtual bridge interface called docker0.

Acts like a virtual switch.

Automatically assigned a subnet: usually 172.17.0.1/16

You can view it on the host with:
ip addr show docker0

#output
5: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 4e:e1:3a:96:d7:f1 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever

#This is the gateway IP for all containers on the bridge.



2. Each Container Gets a veth Pair
For every container, Docker creates a virtual Ethernet pair (veth pair):
One end stays inside the container
The other end is attached to docker0 on the host

| Source â†’ Target                     | Communication    | Notes                                                    |
| ----------------------------------- | ---------------- | -------------------------------------------------------- |
| Container â†’ Host                    | âœ… Yes            | Use host LAN IP (e.g., 192.168.3.1) or add `extra_hosts` |
| Host â†’ Container                    | âŒ Not by default | Use `-p` to publish ports                                |
| Container â†’ Internet                | âœ… Yes            | NAT through host                                         |
| Container â†” Container (same bridge) | âœ… Yes            | Use internal IP (not names)                              |




























====================================================================================================================================================

.......................................................... Production Setup ....................................................................   


			  ***Jenkins and Tuleap on two different servers Tuleap on Server 1 and Jenkins on Server 2***
 
 
#Server-2-Jenkins-(Ubuntu-Machine)

#âœ… Prepare the Environment
--Ensure you're working in a production environment with root privileges (via sudo).

--Choose the proper system location for the Tuleap setup:
--Path: /srv/tuleap/
--This ensures proper organization and security.

#ğŸ“ What is /srv/ in Linux-Ubuntu?
--/srv/ stands for "service".

--It's a standard Linux directory used to store data for server-related services.

--Examples: websites, applications, APIs, databases, etc.


#âœ… Why use /srv/tuleap/ or /srv/jenkins/?
Because Tuleap and Jenkins are server applications, itâ€™s good practice to place their files in /srv/.

#ğŸ”’ Benefits:
------------------------------------------------------------------------------
| Reason                 | Why it's good                                      |
| ---------------------- | -------------------------------------------------- |
| ğŸ“¦ **Organized**       | Keeps all service-related files in one place.      |
| ğŸ” **Secure**          | Easier to manage permissions and restrict access.  |
| ğŸ“ **Standard**        | Follows Linux Filesystem Hierarchy Standard (FHS). |
| ğŸ‘¨â€ğŸ’» **Professional** | Looks clean and is common in production setups.       |
--------------------------------------------------------------------------------


#âœ… 2. ğŸ“ Folder Structure After Creating Jenkins Directory
/srv/
â””â”€â”€ jenkins/                  
    â””â”€â”€ docker-compose.yaml    # Docker Compose configuration for Jenkins service


#âœ… 3. Jenkins Docker Compose File
$ sudo mkdir -p /srv/jenkins
$ cd /srv/jenkins
$ sudo nano docker-compose.yaml  # Create and edit Docker Compose config for jenkins


version: '3.8'

services:
  jenkins:
    image: jenkins/jenkins:lts-jdk17
    hostname: jenkins.isrd.cair.drdo
    container_name: jenkins
    user: root
    ports:
      - "8080:8080"          # Jenkins web interface <host:container>
#      - "50000:50000"        # Jenkins agent communication port <host:container>
    volumes:
      - jenkins_home:/var/jenkins_home              # Persistent Jenkins data
      - /var/run/docker.sock:/var/run/docker.sock   # Docker daemon access
      - /usr/bin/docker:/usr/bin/docker             # Docker CLI access inside container
    environment:
      - JENKINS_HOME=/var/jenkins_home
    restart: always
    networks:
      - jenkins-network

volumes:
  jenkins_home:

networks:
  jenkins-network:
    driver: bridge


#save and exit!



#Explanation:-
#What it does:
1. By default, Jenkins web UI is accessible on the host machine at port 8080.

2. Jenkins agents port (50000) is not exposed (commented out), so remote agents cannot connect unless enabled.
#eg:-
--If you want direct access to Jenkins on port (8080) without SSL, this is fine.

--If you want to secure(8443) Jenkins with SSL, use an NGINX proxy and disable direct port 8080 exposure.

3. Uses a persistent named volume *jenkins_home* which stores Jenkins data inside Dockerâ€™s managed volume storage on the host.

4. #Mounts Docker CLI binary (/usr/bin/docker) and Docker daemon socket (/var/run/docker.sock) inside the container to enable Jenkins pipelines to run Docker commands
1. /var/run/docker.sock:/var/run/docker.sock â€” lets Jenkins talk to the Docker daemon (the service that actually runs containers).

2. /usr/bin/docker:/usr/bin/docker â€” provides the Docker CLI executable inside Jenkins, so Jenkins can issue those Docker commands.
#eg:-
--The socket is the door to Docker on the host.

--The Docker CLI binary is the language or tool Jenkins uses to talk through that door.

--These bind mounts allow Jenkins inside the container to run Docker commands by accessing the hostâ€™s Docker service and CLI.


5. Uses a custom network called jenkins-network so Jenkins can communicate securely with other containers, for NGINX so it can talk to Jenkins securely.
eg:-
networks:
      - my-custom-net
      
6. The container is configured to always restart automatically if it crashes or stops unexpectedly.

7. Volumes in Docker Compose:
Inside the service (under volumes:):
â€œUse this storage inside the container.â€
(Tell Docker: Put this folder or file here inside the container.)

At the bottom of the file (under volumes:):
â€œCreate and keep this storage for me.â€
(Tell Docker: Make a place to keep the data safe and remember it even if the container stops.)

#eg:-
Service part = where to use it

Bottom part = where to create it





#âœ… 4. Map hostname to IP in /etc/hosts

âœ… Way in Production (Multi-Server):(LAN)

âœ… NETWORK & HOST CONFIGURATION
ğŸ”¹ Host Mapping (/etc/hosts) â€” Correctly mapped for 2 separate servers:

| Hostname                 | IP Address    | Role     |
| ------------------------ | ------------- | -------- |
| `tuleap.isrd.cair.drdo`  | `192.168.3.1` | Server 1 |
| `jenkins.isrd.cair.drdo` | `192.168.3.2` | Server 2 |


$ sudo nano /etc/hosts


#On Tuleap server-1 (192.168.3.1):
192.168.3.1    tuleap.isrd.cair.drdo
192.168.3.2    jenkins.isrd.cair.drdo

#On Jenkins server-2 (192.168.3.2):
192.168.3.1    tuleap.isrd.cair.drdo
192.168.3.2    jenkins.isrd.cair.drdo


2ï¸âƒ£ Network Setup
Both servers are connected over LAN with static IPs.

No VPN or Internet is needed.

Hostnames are resolved using /etc/hosts.


3ï¸âƒ£ HTTPS Configuration
Both Tuleap and Jenkins are running with HTTPS, using certificates issued by your internal Certificate Authority (CA).

Ensure both servers trust the CA:
# Example (Ubuntu)
$ sudo cp ca.crt /usr/local/share/ca-certificates/internal-ca.crt
$ sudo update-ca-certificates


4ï¸âƒ£ Firewall Configuration
ğŸ”’ Why UFW Firewall Rules Are Mandatory in LAN Integration (Tuleap â†” Jenkins)
#In a production environment, even on LAN, each server's firewall (like UFW on Ubuntu) controls which IPs and ports can communicate with that server. 

ğŸ”’ On Tuleap Server (192.168.3.1)
# Allow Jenkins (192.168.3.2) to access Tuleap's HTTPS (443)
sudo ufw allow from 192.168.3.2 to any port 443 proto tcp


ğŸ”’ On Jenkins Server (192.168.3.2)
# Allow Tuleap (192.168.3.1) to access Jenkins HTTPS via NGINX
sudo ufw allow from 192.168.3.1 to any port 8443 proto tcp

# (Optional) Allow Tuleap to access Jenkins agent JNLP port
sudo ufw allow from 192.168.3.1 to any port 50000 proto tcp


| Port  | Purpose                       | From â†’ To        | Command Location  | Required?    |
| ----- | ----------------------------- | ---------------- | ----------------- | -----------   |
| 443   | Tuleap HTTPS access           | Jenkins â†’ Tuleap | On Tuleap server  | âœ… Yes       |
| 8443  | Jenkins HTTPS via NGINX       | Tuleap â†’ Jenkins | On Jenkins server | âœ… Yes       |
| 50000 | Jenkins JNLP agent (optional) | Tuleap â†’ Jenkins | On Jenkins server | ğŸ”„ Optional  |



âœ… Verify:
$ sudo ufw status numbered


#Here are the basic UFW firewall commands
sudo ufw enable
sudo ufw disable
sudo ufw status
sudo ufw status numbered
sudo ufw allow <port>
sudo ufw allow from <IP> to any port <port> proto <protocol>
sudo ufw deny <port>
sudo ufw delete <rule_number>
sudo ufw reset



5. # Start Jenkins container in detached mode (runs in background)
$ docker-compose up -d

6. # Access Jenkins web UI in browser default http using hostname and port
Open your browser and navigate to:
http://jenkins.isrd.cair.drdo:8080   or  http://localhost:8080/

7. # Unlock Jenkins first time by retrieving the initial admin password
docker exec -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword

8. # Copy your custom Jenkins plugins from host to Jenkins container
docker cp /home/dell/DevOps-Tools/cair/Docker-Jenkins-Main/Jenkins-Notes/o/jenkins_plugins/. jenkins:/var/jenkins_home/plugins/

9. # Restart Jenkins container to load newly copied plugins
docker restart jenkins

10. # (Optional) Enter Jenkins container shell and verify plugins directory
docker exec -it jenkins bash
cd /var/jenkins_home/plugins
ls -l
exit

11. # Verify Docker networks and volumes to ensure Jenkins setup is correct
docker-compose logs -f jenkins
docker logs jenkins
docker network ls
docker network inspect jenkins-network
docker volume ls




=================================================================================================================================================


				âœ…HTTPS Secure Padlock Setup for Jenkins on Ubuntu Host Machine âœ…
						Jenkins behind NGINX with SSL termination



#Server-2(Jenkins)

#Goal:
#Traffic Flow (graph description):
graph LR
  User(User) --> Nginx[NGINX (HTTPS 443/8443)]
  Nginx --> Jenkins[Jenkins (HTTP 8080 internal)]


--NGINX handles SSL termination â€” it accepts HTTPS traffic on port 8443 (and optionally 443).

--Jenkins runs internally over HTTP on port 8080 â€” no SSL overhead inside the container/network.

--Only required SSL certificate files are mounted into NGINX container.

--Jenkins port 8080 is not exposed directly to the outside world for security.


#âœ… Prepare Directory Structure on Host

/srv/jenkins/
â”œâ”€â”€ docker-compose.yml             # Docker Compose config for Jenkins + Nginx services
â””â”€â”€ jenkins-ssl-setup/             # SSL setup files for Jenkins and Nginx
    â”œâ”€â”€ certs/                     # SSL certificates and keys
    â”‚   â”œâ”€â”€ jenkins.crt.pem        # Jenkins server SSL certificate
    â”‚   â”œâ”€â”€ jenkins.key.pem        # Jenkins private key (keep secure, chmod 600)
    â”‚   â”œâ”€â”€ internal-ca.crt.pem    # Internal Certificate Authority (CA) certificate
    â”‚   â”œâ”€â”€ internal-ca.key.pem    # Internal CA private key (keep secure, chmod 600)
    â”‚   â”œâ”€â”€ jenkins.csr.pem        # Certificate Signing Request for Jenkins cert
    â”‚   â”œâ”€â”€ jenkins-openssl.cnf    # OpenSSL config file for cert generation
    â”‚   â”œâ”€â”€ jenkins.p12            # PKCS#12 format certificate bundle (password protected)
    â”‚   â””â”€â”€ jenkins.jks            # Java Keystore file (password protected)
    â”œâ”€â”€ ca-certificates/           # Additional trusted CA certs for Jenkins
    â”‚   â””â”€â”€ jenkins-ca.crt         # CA cert used to verify other certs
    â”œâ”€â”€ nginx/                     # Nginx config files
    â”‚   â””â”€â”€ jenkins.conf           # Nginx config for reverse proxy and SSL termination
    â”œâ”€â”€ entrypoint.sh              # Custom startup script for Jenkins container (executable)
    â””â”€â”€ tuleap.crt                 # Certificate for Tuleap CA trusted by Jenkins/Nginx


sudo mkdir -p /srv/jenkins/jenkins-ssl-setup/{certs,ca-certificates,nginx}
sudo touch /srv/jenkins/jenkins-ssl-setup/{entrypoint.sh,tuleap.crt}
sudo touch /srv/jenkins/jenkins-ssl-setup/nginx/jenkins.conf


# ğŸ§© ğŸ”§ 1. Create your own Certificate Authority (CA)--ğŸ§© 1. Create Certificate Authority (CA)
#This setup is essential for running your own internal CA with OpenSSL. Without these files, commands like openssl ca will fail.
sudo mkdir -p /etc/pki/CA/newcerts
sudo touch /etc/pki/CA/index.txt
echo '1000' | sudo tee /etc/pki/CA/serial


#Create CA working directory
ğŸ”’ 2. Generate CA Key & Certificate
mkdir -p /srv/jenkins/jenkins-ssl-setup && cd /srv/jenkins/jenkins-ssl-setup


#Generate private key for the CA-------#internal-ca.key.pem
cd certs
sudo openssl genrsa -out internal-ca.key.pem 4096


#Create a CA public certificate -------#internal-ca.crt.pem
sudo openssl req -key internal-ca.key.pem -new -x509 -days 7300 -extensions v3_ca -out internal-ca.crt.pem	

#eg:-
Country Name (2 letter code) [AU]: IN
State or Province Name (full name) [Some-State]: Karnataka
Locality Name (eg, city) []: Bangalore
Organization Name (eg, company) [Internet Widgits Pty Ltd]: DRDO
Organizational Unit Name (eg, section) []: CAIR-ISRD
Common Name (e.g. server FQDN or YOUR name) []: DRDO Internal Certificate Authority
Email Address []: admin@drdo.gov.in


#note:_
--created your own Certificate Authority (CA)! ğŸ‰

--Tuleap and Jenkins on separate servers with HTTPS enabled, using certificates issued by the same internal Certificate Authority (CA).

--Use this Root CA to sign server/client certificates, such as for Jenkins, Tuleap, etc.

--Issue Certs for Tuleap and Jenkins (Separate Servers)

--Generate separate key+CSR for each server

--Use the same CA to sign both


| File                  | Description                       |
| --------------------- | --------------------------------- |
| `internal-ca.key.pem` | Root CA private key (keep secure) |
| `internal-ca.crt.pem` | Root CA certificate (shareable)   |


| Purpose            | Suggested File Name   | Description                                                                          |
| ------------------ | --------------------- | ------------------------------------------------------------------------------------ |
| **CA Private Key** | `internal-ca.key.pem` | This is the **private key** for your internal CA (keep secure)                       |
| **CA Certificate** | `internal-ca.crt.pem` | This is the **public certificate** for your internal CA (share with servers/clients) |


--internal-ca.key.pem â†’ Private key of your internal CA

--internal-ca.crt.pem â†’ Self-signed public certificate of your internal CA



#ğŸ§© 2. Install CA on Host Ubuntu

sudo cp internal-ca.crt.pem /usr/local/share/ca-certificates/jenkins-ca.crt
sudo update-ca-certificates

#eg:-
root@cair:/srv/tuleap/tuleap-ssl-setup# sudo update-ca-certificates
Updating certificates in /etc/ssl/certs...
rehash: warning: skipping ca-certificates.crt,it does not contain exactly one certificate or CRL
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d...
done.

ls -l /etc/ssl/certs/ | grep jenkins-ca

#Now your CA is trusted by Ubuntu.


#note:-
--This allows your Ubuntu host system to trust certificates signed by your internal CA (like Tuleap or Jenkins server certs).
--This process makes your system trust all SSL certificates signed by that CA.
--sudo rm /usr/local/share/ca-certificates/jenkins-ca.crt--(if it had a different extension before.)
--sudo update-ca-certificates --fresh


1. *.crt is required by update-ca-certificates
The update-ca-certificates command only processes .crt files. Your original file was named internal-ca.crt.pem, which may be ignored.

#| Reason           | Explanation                            
| ---------------- | -------------------------------------- |
| `.crt` extension | Required by `update-ca-certificates`   |
| Better naming    | Helps identify its purpose (Tuleap)    |
| Safe operation   | Prevents name clashes with other certs |






=================================================================================================================================================

 . Generate Server Certificate  for Tuleap

#internal-ca.key.pem â†’ Private key of your internal CA

#internal-ca.crt.pem â†’ Self-signed public certificate of your internal CA

Generate separate key+CSR for each server

Use the same CA to sign both


#Add CA key into server-2 host ubuntu location(CA Certificate (Public)
âœ… Your CA Certificate is: internal-ca.crt.pem
This is the certificate that acts as the root of trust. It signed tuleap.crt.pem, and any system (like Jenkins) that wants to trust Tuleap must have this CA certificate installed or imported into its truststore.

| Purpose                   | Correct File          |
| ------------------------- | --------------------- |
| ğŸ” **CA Certificate**     | `internal-ca.crt.pem` |
| ğŸŒ **Tuleap Server Cert** | `tuleap.crt.pem`      |



#.pem is often used for:

Private keys (.key.pem)

Bundles (key + cert + chain)

OpenSSL tooling

#.crt is used for:

System trust stores (like /usr/local/share/ca-certificates/*.crt)

Web servers (NGINX, Apache)


#Copy the CA cert from server1  to server-2 Jenkins host:
scp tuleap-ca.crt    user@ip:/home/user/tmp/

#Move it to the trusted certificates directory:

sudo cp /tmp/tuleap-ca.crt     /usr/local/share/ca-certificates/


#Update the trust store:
sudo update-ca-certificates


#note:-
--This allows your Ubuntu host system to trust certificates signed by your internal CA (like Tuleap or Jenkins server certs).
--This process makes your system trust all SSL certificates signed by that CA.
--Each server needs to trust the same internal CA cert 


==================================================================================================================================================


#3.ğŸ§©Go to ubuntu CA location and copy CA file
cd /usr/local/share/ca-certificates/
sudo cp jenkins-ca.crt    /srv/jenkins/jenkins-ssl-setup/ca-certificates


#note:-
Ubuntu stores custom CA certs at /usr/local/share/ca-certificates/

You copy that cert to your Jenkins SSL setup folder so Jenkins (or Dockerized Jenkins) can use and trust it.

This step ensures Jenkins will trust any SSL certificates signed by your internal CA.



#ğŸ§©4. Generate separate key+CSR for each server(jenkins)

#internal-ca.key.pem â†’ Private key of your internal CA

#internal-ca.crt.pem â†’ Self-signed public certificate of your internal CA

Use the same CA to sign both

ğŸ›  Step-by-Step Jenkins SSL/TLS Setup (On Server 2)
1. Generate Jenkins Private Key----
/srv/jenkins/jenkins-ssl-setup/certs

$ sudo openssl genrsa -out jenkins.key.pem 2048
#jenkins.key.pem



2. Create OpenSSL config for Jenkins (jenkins-openssl.cnf)
sudo cp /etc/ssl/openssl.cnf .
sudo mv openssl.cnf jenkins-openssl.cnf
sudo nano jenkins-openssl.cnf

#Edit it (nano jenkins-openssl.cnf) and update:
âœ… What to change in jenkins-openssl.cnf
####################################################################
[ CA_default ]
dir             = /etc/pki/CA   # ir = /etc/pki/CA sets the base directory where the CAâ€™s files (private keys, certificates, databases, serial numbers, etc.) are stored.
####################################################################
[ req ]
default_bits        = 2048
default_keyfile     = privkey.pem
distinguished_name  = req_distinguished_name
attributes          = req_attributes
req_extensions      = v3_req

####################################################################
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = jenkins.isrd.cair.drdo   # Your Jenkins domain here
#IP.1 = 192.168.3.2

#Save and exit.



#ğŸ§©5. Generate CSR-----#jenkins.csr.pem
sudo openssl req -config jenkins-openssl.cnf -key jenkins.key.pem -new -out jenkins.csr.pem


#keys
#internal-ca.crt.pem  internal-ca.key.pem  jenkins.csr.pem  jenkins.key.pem  jenkins-openssl.cnf



#Prepare CA directories (if not already done)
sudo mkdir -p /etc/pki/CA/newcerts
sudo chmod 700 /etc/pki/CA/newcerts
sudo chown root:root /etc/pki/CA/newcerts


#Sign server certificate with CA--------------#jenkins.crt.pem
sudo openssl ca -config jenkins-openssl.cnf -extensions v3_req -days 3650 \
-in jenkins.csr.pem -out jenkins.crt.pem \
-cert internal-ca.crt.pem -keyfile internal-ca.key.pem



#When prompted:
out of 1 certificate requests certified, commit? [y/n] y
Write out database with 1 new entries
Data Base Updated


âœ… Output files:
jenkins.crt.pem â€” Jenkins server certificate

jenkins.key.pem â€” Jenkins private key

internal-ca.crt.pem â€” CA certificate (same for all)


#keys

#internal-ca.crt.pem  internal-ca.key.pem  jenkins.crt.pem  jenkins.csr.pem  jenkins.key.pem  jenkins-openssl.cnf

--------------------------------------------------------------------------------------------------------------------------------------------------
| File Name             | Purpose                                              | Status                                                         |
| --------------------- | ---------------------------------------------------- | ------------------------------------------------------------    |
| `jenkins.key.pem`     | âœ… Jenkins private key                                | âœ… OK                                                         |
| `jenkins-openssl.cnf` | âœ… OpenSSL config for CSR (with subject/SAN)          | âœ… OK                                                         |
| `jenkins.csr.pem`     | âœ… CSR generated using the key + config               | âœ… OK                                                         |
| `internal-ca.crt.pem` | âœ… CA certificate used to trust the server cert       | âœ… OK                                                         |
| `internal-ca.key.pem` | âœ… CA private key used to sign Jenkins cert           | âœ… OK                                                         |
| `jenkins.crt.pem`     | âœ… Final server certificate for Jenkins, signed by CA | âœ… OK                                                         |
| `undercloud.conf`     | â“ Unknown â€” not part of Jenkins HTTPS setup          | âŒ Not needed (unless youâ€™re using it for something specific) |
--------------------------------------------------------------------------------------------------------------------------------------------------



#âœ… jenkins.csr.pem   jenkins-openssl.cnf  jenkins.key.pem   internal-ca.crt.pem   internal-ca.key.pem  jenkins.crt.pem

#âœ… Why convert PEM to PKCS12 (.p12)
PEM files (like .crt.pem and .key.pem) are standard in Linux environments.

But Java applications (like Jenkins) can't use PEM files directly.

The PKCS#12 (.p12) format bundles the certificate, private key, and CA chain into one secure file â€” and Java can understand this format.

ğŸ›  So this step is needed to go from Linux-friendly format â†’ Java-friendly format.


#âœ… Why convert PKCS12 to JKS (.jks)
Jenkins (or other Java apps) often expect a Java KeyStore (JKS) format, especially when configured to use SSL directly (e.g., in embedded Jetty or Tomcat).

The .jks format is Java's native keystore format and is easier to manage using the keytool utility.

ğŸ” So this step is needed because .jks is the format Jenkins expects for SSL setup.


#ğŸ§©6. Convert PEM files to PKCS12 Format


sudo openssl pkcs12 -export -in /srv/jenkins/jenkins-ssl-setup/certs/jenkins.crt.pem -inkey /srv/jenkins/jenkins-ssl-setup/certs/jenkins.key.pem -out /srv/jenkins/jenkins-ssl-setup/certs/jenkins.p12 -name jenkins -CAfile /srv/jenkins/jenkins-ssl-setup/certs/internal-ca.crt.pem -caname root -password pass:cair123



#ğŸ§©7. Convert PKCS12 to JKS Format:
sudo keytool -importkeystore -deststorepass cair123 -destkeypass cair123 -destkeystore /srv/jenkins/jenkins-ssl-setup/certs/jenkins.jks -srckeystore /srv/jenkins/jenkins-ssl-setup/certs/jenkins.p12 -srcstoretype PKCS12 -srcstorepass cair123 -alias jenkins


#permissions
sudo chown -R $USER:$USER /srv/jenkins/jenkins-ssl-setup/certs
sudo chmod -R 755 /srv/jenkins/jenkins-ssl-setup/certs


#output files
---------------------------------------------------------------------------------------------------------------
| File Format            | Simple Definition                                                                  |
| ---------------------- | ---------------------------------------------------------------------------------- |
| `.pem`                 | Standard format for certificates and keys in Linux. Not directly usable by Java.   |
| `.p12` (PKCS12)        | A single file that bundles your certificate, private key, and CA certificate.      |
| `.jks` (Java KeyStore) | A secure file Java applications (like Jenkins) use to store certificates and keys. |
---------------------------------------------------------------------------------------------------------------

#final keys
# internal-ca.crt.pem  internal-ca.key.pem  jenkins.crt.pem  jenkins.csr.pem  jenkins.jks  jenkins.key.pem  jenkins-openssl.cnf  jenkins.p12









#ğŸ§©8. Jenkins and Tuleap run on separate servers (or containers), Jenkins needs to trust Tuleapâ€™s SSL certificate.

| Certificate type   | Use in Jenkins setup?            | Typical file/location                                    |
| ------------------ | -------------------------------- | -------------------------------------------------------- |
| Tuleap public cert | **YES** â€” for Jenkins trust      | `/srv/tuleap/tuleap-ssl-setup/certs/server.crt.pem`      |


#tuleap.crt
The serverâ€™s public SSL/TLS certificate file used by Tuleap (or Jenkins) to establish secure HTTPS connections. This certificate is shared with clients or other servers (e.g., Jenkins trusting Tuleap) to verify the serverâ€™s identity.

#process

1. login tuleap container
docker exec -it <tuleap-container-name> bash

2. openssl s_client -connect tuleap.isrd.cair.drdo:443 -showcerts
3. Save the Tuleap server's certificate (-----BEGIN CERTIFICATE-----  to -----END CERTIFICATE-----)
#âœ… This is Tuleap's public certificate.

4. copy the certificate into a host location  

#or
docker exec -it <tuleap-container-name> /bin/bash
openssl s_client -connect tuleap.isrd.cair.drdo:443 -showcerts </dev/null 2>/dev/null | openssl x509 -outform PEM > /tmp/tuleap.crt
exit
docker exec <tuleap-container-name> cat /etc/pki/tls/certs/server.crt.pem > /tmp/tuleap.crt
scp /tmp/tuleap.crt user@jenkins-server:/srv/jenkins/jenkins-ssl-setup/certs/tuleap.crt



5. On the Jenkins host, create file:
/srv/jenkins/jenkins-ssl-setup/tuleap.crt
sudo nano tuleap.crt
# Paste Tuleap server cert here (-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-----)






#ğŸ§©9. entrypoint.sh (host) script for Jenkins
--The entrypoint.sh script ensures that Jenkins trusts your internal TLS certificate (like Tuleap's) before Jenkins starts.
--Adding Tuleap's SSL certificate (signed by your internal CA) into the Java truststore used by Jenkins.

| Step                             | Reason                                 |
| -------------------------------- | -------------------------------------- |
| `update-ca-certificates`         | OS trusts internal CA                  |
| `keytool -import`                | Java/Jenkins trusts Tuleap CA cert     |
| `exec /usr/local/bin/jenkins.sh` | Launch Jenkins with updated truststore |

#process

âœ… Tuleap's SSL cert (tuleap.crt) is copied or mounted to:
/etc/ssl/certs/tuleap.crt

âœ… You are importing this cert into Java's truststore at:
/opt/java/openjdk/lib/security/cacerts
(This is where Jenkins' JVM looks for trusted CAs)

âœ… After trusting the cert, the script starts Jenkins using:
exec /usr/local/bin/jenkins.sh


#ğŸ’¡ Why This Matters
--If you skip this, Jenkins might refuse to connect to Tuleap or show SSL errors, because it's using a self-signed cert.
--Jenkins will trust HTTPS connections to Tuleap, and you won't get SSL errors when Jenkins talks to Tuleap (e.g., webhooks, Git repo access, etc.).


$ sudo nano entrypoint.sh 

#!/bin/bash

# Update CA certificates on Jenkins server
update-ca-certificates

# Import Tuleap's CA cert into Jenkins Java truststore
keytool -import -noprompt -trustcacerts -alias tuleap \
  -keystore /opt/java/openjdk/lib/security/cacerts \
  -file /etc/ssl/certs/tuleap.crt \
  -storepass changeit

# Start Jenkins
exec /usr/local/bin/jenkins.sh


#or--m

#!/bin/bash

# Auto-map nginx container IP in /etc/hosts (avoid duplicate entries)
NGINX_IP=$(getent hosts jenkins-nginx | awk '{ print $1 }')
grep -q "jenkins.isrd.cair.drdo" /etc/hosts || echo "$NGINX_IP jenkins.isrd.cair.drdo" >> /etc/hosts

# Trust Jenkins CA
cp /etc/ssl/certs/jenkins-ca.crt /usr/local/share/ca-certificates/jenkins-ca.crt
update-ca-certificates

# Trust Tuleap CA
keytool -import -noprompt -trustcacerts -alias tuleap \
  -keystore /opt/java/openjdk/lib/security/cacerts \
  -file /etc/ssl/certs/tuleap.crt \
  -storepass changeit

# Start Jenkins
exec /usr/local/bin/jenkins.sh


#save and exit !

$ sudo chmod +x entrypoint.sh











#ğŸ§©10. Recommended: Run NGINX in a Docker container
#Use NGINX inside a Docker container
--------------------------------------------------------------------------------------------
| Feature                          | NGINX in Docker           | NGINX on Host             |
| -------------------------------- | -----------------------   | ------------------------- |
| Easy to deploy and update        | âœ… Yes                   | âŒ Needs OS package mgmt   |
| Matches your Docker-based setup  | âœ… Yes                   | âŒ Breaks consistency      |
| Volume mapping for certs/configs | âœ… Simple with `-v`      | âœ… Possible but less clean |
| Cleaner rollback/testing         | âœ… Easy (`compose down`) | âŒ Risk of OS-level break  |
| Host remains lightweight         | âœ… Yes                   | âŒ NGINX runs natively     |
---------------------------------------------------------------------------------------------

âœ… Final Recap â€” What You Should Do on Jenkins Separate Server:
--Do NOT install NGINX on the host.

--Use a Docker-based NGINX container to:

--Handle HTTPS using your self-signed CA,

--Reverse proxy to Jenkins (port 8080).





#âœ… Step 1: Pull NGINX Image (from Docker Hub)
docker pull nginx:latest
docker save nginx:latest -o nginx-latest.tar
docker load -i nginx-latest.tar
docker images

#eg:-
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    abcdef123456   2 weeks ago    142MB


# Run Jenkins + NGINX with Docker Compose

NGINX in Docker with your custom SSL config for Jenkins

1. âœ… Directory Structure Assumption
/srv/jenkins/
â”œâ”€â”€ docker-compose.yaml             # Jenkins + NGINX docker-compose file
â””â”€â”€ jenkins-ssl-setup/              # All SSL/TLS related files here
    â”œâ”€â”€ certs/                     # Certificates and keys
    â”‚   â”œâ”€â”€ jenkins.crt.pem        # Jenkins SSL certificate
    â”‚   â”œâ”€â”€ jenkins.key.pem        # Jenkins private key
    â”‚   â”œâ”€â”€ internal-ca.crt.pem    # Internal CA certificate that signed Jenkins cert
    â”‚   â”œâ”€â”€ jenkins.p12            # PKCS#12 bundle (cert + key + CA)
    â”‚   â””â”€â”€ jenkins.jks            # Java Keystore file for Jenkins
    â”œâ”€â”€ ca-certificates/            # CA certs folder (if you have other CA certs here)
    â”‚   â””â”€â”€ jenkins-ca.crt          # Example CA cert for Tuleap mutual trust
    â”œâ”€â”€ nginx/                     # Custom nginx config files for Jenkins
    â”‚   â””â”€â”€ jenkins.conf           # NGINX config file (reverse proxy with SSL)
    â”œâ”€â”€ entrypoint.sh              # Custom Jenkins entrypoint script (optional)
    â””â”€â”€ tuleap.crt                 # Tuleap certificate for mutual trust if needed


2. âœ… Create the jenkins.conf File

Location: /srv/jenkins/jenkins-ssl-setup/nginx/jenkins.conf

sudo nano jenkins.conf

#main

server {
    listen 443 ssl;
    server_name jenkins.isrd.cair.drdo;

    ssl_certificate /etc/nginx/certs/jenkins.crt.pem;
    ssl_certificate_key /etc/nginx/certs/jenkins.key.pem;
    ssl_trusted_certificate /etc/nginx/certs/internal-ca.crt.pem;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;

    location / {
        proxy_pass http://jenkins:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

server {
    listen 80;
    server_name jenkins.isrd.cair.drdo;
    return 301 https://$host$request_uri;
}


#or

server {
    listen 443 ssl http2;  # http2 for better performance
    server_name jenkins.isrd.cair.drdo;

    # SSL Certificates
    ssl_certificate /etc/nginx/certs/jenkins.crt.pem;
    ssl_certificate_key /etc/nginx/certs/jenkins.key.pem;
    ssl_trusted_certificate /etc/nginx/certs/internal-ca.crt.pem;

    # SSL Protocols & Ciphers (Strong, but compatible)
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;

    # SSL Performance Optimizations
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Security Headers
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";
    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-Content-Type-Options "nosniff";
    add_header Referrer-Policy "strict-origin";

    # Jenkins Proxy Settings
    location / {
        proxy_pass http://jenkins:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Jenkins-specific optimizations
        proxy_request_buffering off;
        proxy_buffering off;  # Disable buffering for real-time logs
        client_max_body_size 50M;  # Allow large file uploads
    }
}

# Redirect HTTP to HTTPS
server {
    listen 80;
    server_name jenkins.isrd.cair.drdo;
    return 301 https://$host$request_uri;
}

#save and exit!



#Note:-

âœ… Simple HTTPS Flow for Jenkins via NGINX:
User types:
http://jenkins.isrd.cair.drdo
ğŸ” NGINX listens on port 80 â†’ sends 301 redirect to HTTPS (https://jenkins.isrd.cair.drdo:8443)

Browser connects to:
https://jenkins.isrd.cair.drdo:8443
âœ… NGINX listens on port 8443 (SSL)
âœ… Uses TLS certs stored in /etc/nginx/certs/ to establish a secure connection

NGINX decrypts HTTPS â†’
ğŸš€ Forwards request to Jenkins over HTTP at http://jenkins:8080

Jenkins (on port 8080) receives the internal request
ğŸ› ï¸ Processes it (e.g., login, dashboard, trigger builds)

Jenkins sends back an HTTP response to NGINX
ğŸ”’ NGINX re-wraps the response in HTTPS

Userâ€™s browser gets a secure response
ğŸŒ The Jenkins UI is now displayed securely using https://jenkins.isrd.cair.drdo:8443


| Port | Purpose                                       |
| ---- | --------------------------------------------- |
| 80   | Accepts HTTP â†’ redirects to HTTPS             |
| 8443 | Accepts HTTPS â†’ decrypts & proxies to Jenkins |




#Step-by-step for Jenkins behind NGINX TLS reverse proxy (Server 2)
3. âœ… Final docker-compose.yml for Jenkins (With NGINX TLS Proxy)

#Docker Compose (/srv/jenkins/docker-compose.yaml)
$ sudo nano docker-compose.yaml  # Create and edit Docker Compose config for jenkins

version: '3.8'

services:
  jenkins:
    image: jenkins/jenkins:lts-jdk17
    hostname: jenkins.isrd.cair.drdo
    container_name: jenkins
    user: root
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock  # Security risk! Only use in trusted environments.
      - /usr/bin/docker:/usr/bin/docker
      - /srv/jenkins/jenkins-ssl-setup/certs:/var/jenkins_home/ssl
      - /srv/jenkins/jenkins-ssl-setup/ca-certificates/jenkins-ca.crt:/etc/ssl/certs/jenkins-ca.crt
      - /srv/jenkins/jenkins-ssl-setup/tuleap.crt:/etc/ssl/certs/tuleap.crt
      - /srv/jenkins/jenkins-ssl-setup/entrypoint.sh:/entrypoint.sh
    environment:
      - JENKINS_HOME=/var/jenkins_home
      - JENKINS_OPTS=--httpPort=8080 --httpsPort=-1  # Disable built-in HTTPS (Nginx handles SSL)
    entrypoint: /entrypoint.sh
    extra_hosts:
      - "jenkins.isrd.cair.drdo:172.18.0.3"  # Ensures container resolves its own hostname
    networks:
      jenkins-network:
        aliases:
          - jenkins.isrd.cair.drdo  # Alternative to extra_hosts (if using Docker DNS)
    restart: unless-stopped


  nginx:
    image: nginx:latest
    container_name: jenkins-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /srv/jenkins/jenkins-ssl-setup/nginx/jenkins.conf:/etc/nginx/conf.d/default.conf
      - /srv/jenkins/jenkins-ssl-setup/certs:/etc/nginx/certs
    depends_on:
      - jenkins
    networks:
      - jenkins-network
    restart: unless-stopped

volumes:
  jenkins_home:

networks:
  jenkins-network:
    driver: bridge
    
    
#save and exit !

==========================================================================================================================================
#note
# âŒ Problem: No hostname mapping by default
# When Tuleap tries to reach Jenkins using a full domain (like jenkins.isrd.cair.drdo), it fails unless the hostname is resolvable.

# entrypoint: /entrypoint.sh
# This script initializes Jenkins â€” commonly used to set environment variables, install plugins, trust certificates, etc.


# âœ… Option 1: Use extra_hosts (Manual IP Mapping)
extra_hosts:
  - "jenkins.isrd.cair.drdo:172.18.0.3"
# Meaning:
# Inside the container, any request to "jenkins.isrd.cair.drdo" will be directed to IP 172.18.0.3.
# This updates the container's internal /etc/hosts file with a manual entry.


# ğŸ” How /etc/hosts works in Docker:
# - Docker auto-generates an /etc/hosts file inside each container.
# - It contains default entries like:
#       127.0.0.1 localhost
# - Without extra_hosts, custom hostnames like jenkins.isrd.cair.drdo are not resolvable.
# - Result: Tuleap webhooks or API calls to Jenkins by hostname will fail with "server not reachable".


# âœ… Option 2: Use Docker DNS with network aliases (Recommended for internal services)
networks:
  jenkins-network:
    aliases:
      - jenkins.isrd.cair.drdo
# Meaning:
# Docker's internal DNS will automatically map "jenkins.isrd.cair.drdo" to the correct container IP.
# No need to manually specify IPs â€” better for dynamic and scalable setups.


# ğŸ”„ What breaks if hostname is not resolvable:
# - Tuleap â†’ Jenkins webhook using http://jenkins.isrd.cair.drdo â†’ âŒ "Server not reachable"
# - Any API call or lookup from one container to another using FQDN â†’ âŒ Fails

# ğŸŸ¢ Recommendation:
# - Use `network.aliases` when all services are on the same Docker network (cleaner and scalable).
# - Use `extra_hosts` only when DNS is not an option (e.g., cross-network or talking to host-only services).




    entrypoint: tells Docker what to run

    volume: provides your custom version of the file


#Why?
--extra_hosts or aliases are needed for Docker containers to resolve jenkins.isrd.cair.drdo to the correct container IP.

--The entrypoint.sh script might contain setup commands required for Jenkins to start properly.

#ğŸ§  Think of jenkins.isrd.cair.drdo as a name.
You need to tell Docker:

â€œHey, what IP should I use when I try to connect to jenkins.isrd.cair.drdo?â€


| Aspect                  | Uncommented (Active)                                       | Commented (Inactive)                        |
| ----------------------- | ---------------------------------------------------------- | ------------------------------------------- |
| **Entrypoint**          | Runs `/entrypoint.sh` to start Jenkins                     | No startup script, Jenkins may not run      |
| **Hostname resolution** | `extra_hosts` maps hostname to IP inside container         | No mapping, hostname wonâ€™t resolve          |
| **Docker DNS alias**    | Network alias lets Docker DNS resolve hostname dynamically | No alias, Docker DNS wonâ€™t resolve hostname |
| **Result**              | Jenkins starts and hostname works                          | Hostname fails, connection refused          |


| Location                 | `jenkins.isrd.cair.drdo` resolves to |
| ------------------------ | ------------------------------------ |
| Inside Jenkins container | `172.18.0.3` (internal Docker IP)    |
| On your host machine     | `192.168.3.2` (via `/etc/hosts`)     |



#Uncommented: Hostname works, Jenkins starts properly, network resolves jenkins.isrd.cair.drdo.

#Commented: Hostname resolution breaks, Jenkins may not start correctly, connection to jenkins.isrd.cair.drdo fails.




=================================================================================================================================================



#ğŸ¦Š Steps to Import internal-ca.crt.pem into Firefox
--Open Firefox.

--Settings â†’ Privacy & Security â†’ Certificates

--Click â€œView Certificates

--In the Certificate Manager window:

--Go to the Authorities tab.

--Click Import.

--Locate and select your certificate file:
/srv/tuleap/tuleap-ssl-setup/certs/internal-ca.crt.pem

--On the trust dialog, check both boxes:

âœ… Trust this CA to identify websites

âœ… (optional) Trust to identify email users (not required for Tuleap)


--Click OK.


#Reload your Tuleap site (e.g., https://tuleap.isrd.cair.drdo) and the warning should be gone.




#ğŸ”’ Why Manual Import Is Needed in Firefox
ğŸ§  1. Firefox uses its own certificate store (not the system's)
Unlike Chrome or curl (which use your OS-level trusted CA certificates), Firefox maintains its own internal certificate store.

So even if your CA (tuleap-ca.crt.pem) is trusted system-wide, Firefox wonâ€™t see it unless you import it manually.


ğŸ”„ 2. Self-signed Certificate Authorities are not globally trusted
Since your Tuleap HTTPS setup uses a self-signed CA, itâ€™s not included in any global trusted list.

Firefox (and other browsers) block these by default unless you explicitly trust the CA.



# Start Jenkins container in detached mode (runs in background)
docker-compose down
docker-compose up -d


#Browser access
https://tuleap.isrd.cair.drdo	 	(secure browser)    server-1
https://jenkins.isrd.cair.drdo	 	(secure browser)    server-2


#Logs 
docker logs jenkins
docker logs -f jenkins
docker exec jenkins-nginx nginx -t


#verify 
#Host and container verify the certificates
openssl s_client --connect jenkins.isrd.cair.drdo:8443
docker exec -it jenkins keytool -list -keystore  opt/java/openjdk/lib/security/cacerts -storepass changeit | grep tuleap
keytool -list -keystore /opt/java/openjdk/lib/security/cacerts -storepass changeit | grep tuleap

#âœ… Check Java Truststore (cacerts) for Your CA
$ keytool -list -keystore /opt/java/openjdk/lib/security/cacerts -storepass changeit | grep tuleap

# Host: Check full cert chain is valid(host~container)
curl -Iv https://jenkins.isrd.cair.drdo

#jenkins~tuleap
curl -Iv https://tuleap.isrd.cair.drdo

#eg:-
âœ… Jenkins can reach Tuleap via HTTPS.

âœ… Jenkins trusts Tuleapâ€™s certificate.

âœ… Tuleap is working properly on port 443 and responds correctly.

ğŸŒ The domain tuleap.isrd.cair.drdo resolves inside Jenkins.

#tuleap~jenkins
curl -Iv https://jenkins.isrd.cair.drdo






==================================================================================================================================================

#note:-
--You can use any valid network name you want, such as {jenkins-network, shared-network, tuleap-jenkins-net, etc.}

--If multiple services need to communicate, they must share the same network name.

--The Docker Compose network name can be different from the service names â€” using custom network names helps improve clarity and service isolation.


#TL;DR
Before: Jenkins handled HTTPS â†’ needed keystore + certs inside Jenkins container

Now: NGINX handles HTTPS â†’ Jenkins only HTTP, so no need for keystore or certs in Jenkins container



		    ***Production Docker Architecture: Tuleap (Server 1) & Jenkins (Server 2) with NGINX TLS Termination***

âœ… Jenkins must trust Tuleapâ€™s server certificate to securely interact with Tuleap services (e.g., via REST API calls).

âœ… Tuleap must trust Jenkinsâ€™ server certificate if it needs to call back securely (e.g., webhooks, integrations).

âœ… Each server runs NGINX reverse proxy in a container, handling all external TLS/SSL termination.

âœ… Application containers (Jenkins & Tuleap) run over plain HTTP internally, keeping SSL management outside the apps.

âœ… NGINX exposes HTTPS to users/clients, using mounted server certificates and trusted CA files.

âœ… Both servers share a common internal CA, allowing mutual trust between services and verifying certificate authenticity.

âœ… This architecture simplifies container configuration, centralizes TLS management, and follows strong security best practices.



================================================================================================================================================

#Jenkins compose file recap

# Docker Compose version 3.8 (supports modern Docker features)
version: '3.8'

# Define the services/containers that make up the application
services:
  # Jenkins service - the main CI/CD server
  jenkins:
    image: jenkins/jenkins:lts-jdk17  # Official Jenkins image with LTS and Java 17
    hostname: jenkins.isrd.cair.drdo   # Sets the hostname inside the container
    container_name: jenkins           # Explicit name for the container
    user: root                        # Runs as root (required for Docker integration but has security implications)
    
    # Volume mounts:
    volumes:
      # Persistent storage for Jenkins data (managed by Docker as a named volume)
      - jenkins_home:/var/jenkins_home
      
      # Gives Jenkins access to host's Docker daemon (enables Docker-in-Docker but is a security risk)
      - /var/run/docker.sock:/var/run/docker.sock
      
      # Makes host's Docker CLI available in the container
      - /usr/bin/docker:/usr/bin/docker
      
      # Mount SSL certificates directory
      - /srv/jenkins/jenkins-ssl-setup/certs:/var/jenkins_home/ssl
      
      # Trusts Tuleap's CA certificate (likely for integration with Tuleap system)
      - /srv/jenkins/jenkins-ssl-setup/tuleap.crt:/etc/ssl/certs/tuleap.crt
      
      # Custom startup script that will run instead of the default Jenkins entrypoint
      - /srv/jenkins/jenkins-ssl-setup/entrypoint.sh:/entrypoint.sh
    
    # Environment variables
    environment:
      - JENKINS_HOME=/var/jenkins_home  # Where Jenkins stores its data
      - JENKINS_OPTS=--httpPort=8080 --httpsPort=-1  # Runs on HTTP 8080, disables HTTPS (letting Nginx handle SSL)
    
    # Override the default entrypoint with custom script
    entrypoint: /entrypoint.sh
    
    # Network configuration
    networks:
      - jenkins-network  # Attaches to custom network
    
    restart: unless-stopped  # Automatically restarts unless explicitly stopped

  # Nginx service - acts as a reverse proxy for Jenkins
  nginx:
    image: nginx:latest       # Latest official Nginx image
    container_name: jenkins-nginx  # Explicit container name
    ports:
      - "80:80"              # Exposes HTTP port
      - "8443:8443"          # Exposes HTTPS on 8443 (avoids conflict with Tuleap on 443)
    
    # Volume mounts:
    volumes:
      # Custom Nginx configuration file
      - /srv/jenkins/jenkins-ssl-setup/nginx/jenkins.conf:/etc/nginx/conf.d/default.conf
      
      # SSL certificates for HTTPS termination
      - /srv/jenkins/jenkins-ssl-setup/certs:/etc/nginx/certs
    
    # Depends on Jenkins service (waits for Jenkins to start)
    depends_on:
      - jenkins
    
    restart: unless-stopped  # Auto-restart policy
    networks:
      - jenkins-network  # Same network as Jenkins

# Volume definitions
volumes:
  # Named volume for Jenkins data (Docker manages storage location, typically in /var/lib/docker/volumes/)
  jenkins_home:

# Network definitions
networks:
  # Custom bridge network for communication between containers
  jenkins-network:
    driver: bridge  # Default network driver (containers can communicate but are isolated from host network)




1. Jenkins Service
services:
  jenkins:
    image: jenkins/jenkins:lts-jdk17
    hostname: jenkins.isrd.cair.drdo
    container_name: jenkins
    user: root
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
      - /usr/bin/docker:/usr/bin/docker
      - /srv/jenkins/jenkins-ssl-setup/certs:/var/jenkins_home/ssl
      - /srv/jenkins/jenkins-ssl-setup/tuleap.crt:/etc/ssl/certs/tuleap.crt
      - /srv/jenkins/jenkins-ssl-setup/entrypoint.sh:/entrypoint.sh
    environment:
      - JENKINS_HOME=/var/jenkins_home
      - JENKINS_OPTS=--httpPort=8080 --httpsPort=-1
    entrypoint: /entrypoint.sh
    networks:
      - jenkins-network
    restart: unless-stopped


#Explanation:
# Docker Compose version 3.8 (supports modern Docker features)
version: '3.8'

# Define the services/containers that make up the application
services:
  # Jenkins service - the main CI/CD server

Image: Uses the official Jenkins LTS (Long-Term Support) image with Java 17.

Hostname: Sets the internal hostname to jenkins.isrd.cair.drdo.

Container Name: Explicitly names the container jenkins.

User: Runs as root (required for Docker socket access but introduces security risks).

Volumes:

jenkins_home:/var/jenkins_home â†’ Persistent storage for Jenkins data.

/var/run/docker.sock:/var/run/docker.sock â†’ Allows Jenkins to control the hostâ€™s Docker daemon (security risk!).

/usr/bin/docker:/usr/bin/docker â†’ Makes the hostâ€™s Docker CLI available inside the container.

/srv/jenkins/jenkins-ssl-setup/certs:/var/jenkins_home/ssl â†’ Mounts SSL certificates.

/srv/jenkins/jenkins-ssl-setup/tuleap.crt:/etc/ssl/certs/tuleap.crt â†’ Trusts Tuleapâ€™s CA certificate.

/srv/jenkins/jenkins-ssl-setup/entrypoint.sh:/entrypoint.sh â†’ Custom startup script.

Environment Variables:

JENKINS_HOME=/var/jenkins_home â†’ Defines Jenkins' home directory.

JENKINS_OPTS=--httpPort=8080 --httpsPort=-1 â†’ Runs Jenkins on HTTP port 8080 and disables HTTPS (since Nginx handles SSL).

Entrypoint: Overrides the default startup script with a custom one (/entrypoint.sh).

Networks: Connects to the custom jenkins-network.

Restart Policy: Automatically restarts unless manually stopped.



2. Nginx Service (Reverse Proxy)
  nginx:
    image: nginx:latest
    container_name: jenkins-nginx
    ports:
      - "80:80"
      - "8443:8443"
    volumes:
      - /srv/jenkins/jenkins-ssl-setup/nginx/jenkins.conf:/etc/nginx/conf.d/default.conf
      - /srv/jenkins/jenkins-ssl-setup/certs:/etc/nginx/certs
    depends_on:
      - jenkins
    restart: unless-stopped
    networks:
      - jenkins-network


#Explanation:
Image: Uses the latest official Nginx image.

Container Name: Explicitly names the container jenkins-nginx.

Ports:

80:80 â†’ Exposes HTTP (unencrypted traffic, usually redirects to HTTPS).

8443:8443 â†’ Exposes HTTPS on 8443 (avoids conflict with Tuleap on 443).

Volumes:

/srv/jenkins/jenkins-ssl-setup/nginx/jenkins.conf:/etc/nginx/conf.d/default.conf â†’ Custom Nginx configuration.

/srv/jenkins/jenkins-ssl-setup/certs:/etc/nginx/certs â†’ SSL certificates for HTTPS.

Depends On: Ensures Nginx starts only after Jenkins is running.

Restart Policy: Automatically restarts unless manually stopped.

Networks: Connects to the same jenkins-network as Jenkins.



3. Volumes (Persistent Storage)
volumes:
  jenkins_home:
  
#Explanation:
Creates a Docker-managed volume named jenkins_home for storing Jenkins data.

Ensures Jenkins configurations, plugins, and job history persist across container restarts.

Default storage location: /var/lib/docker/volumes/


4. Networks (Container Communication)

networks:
  jenkins-network:
    driver: bridge
    

#Explanation:
Defines a custom bridge network named jenkins-network.

Bridge Network: Allows Jenkins and Nginx to communicate securely while isolating them from the host network.

Improves security and makes inter-container communication easier (e.g., Nginx can route traffic to Jenkins using the container name).



| Component | Purpose              | Key Notes                                                             |
| --------- | -------------------- | --------------------------------------------------------------------- |
| Jenkins   | CI/CD Server         | Runs on HTTP 8080, integrates with Docker, persistent storage.        |
| Nginx     | Reverse Proxy        | Handles SSL termination (HTTPS on 8443), forwards traffic to Jenkins. |
| Volumes   | Data Persistence     | Ensures Jenkins data survives container restarts.                     |
| Networks  | Secure Communication | Isolates Jenkins and Nginx while allowing them to communicate.        |



=======================================================================================================================================

#Jenkins.conf file

server {
    listen 8443 ssl;
    server_name jenkins.isrd.cair.drdo;

    ssl_certificate /etc/nginx/certs/jenkins.crt.pem;
    ssl_certificate_key /etc/nginx/certs/jenkins.key.pem;
    ssl_trusted_certificate /etc/nginx/certs/internal-ca.crt.pem;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;

    location / {
        proxy_pass http://jenkins:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

server {
    listen 80;
    server_name jenkins.isrd.cair.drdo;
    return 301 https://$host:8443$request_uri;
}
























































































































